name: Dynamic Multi-App Heroku Deploy

on:
  push:
    branches:
      - main # Or 'master'
    paths:
      - 'homepage-app/**'
      - '.github/workflows/dynamic-deploy.yml'

jobs:
  find_apps: # Job 1: Finds all deployable app directories
    runs-on: ubuntu-latest
    outputs:
      app_dirs_json: ${{ steps.scan.outputs.app_dirs_json }}
    env:
      APP_BASE_DIRS: "homepage-app" # The top-level folder where your apps are

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq (for package.json parsing and JSON output)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Scan for Apps
        id: scan
        run: |
          set -e

          ALL_APP_DIRS_ARRAY=()
          echo "Scanning for apps in: $APP_BASE_DIRS"
          for BASE_DIR in $APP_BASE_DIRS; do
            FOUND_DIRS=$(find "$BASE_DIR" -type f -name "package.json" -exec dirname {} \;)
            for DIR in $FOUND_DIRS; do
              ALL_APP_DIRS_ARRAY+=("$DIR")
            done
          done

          UNIQUE_APP_DIRS_NEWLINES=$(printf "%s\n" "${ALL_APP_DIRS_ARRAY[@]}" | sort -u)

          if [ -z "$UNIQUE_APP_DIRS_NEWLINES" ]; then
            echo "No applications found with package.json in '$APP_BASE_DIRS'. Exiting."
            printf "app_dirs_json=[]\n" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found applications in directories (for debugging):"
          echo "$UNIQUE_APP_DIRS_NEWLINES"

          APP_DIRS_JSON=$(echo "$UNIQUE_APP_DIRS_NEWLINES" | jq -R . | jq -s -c .)
          echo "Generated JSON (single line): $APP_DIRS_JSON"

          printf "app_dirs_json=%s\n" "$APP_DIRS_JSON" >> "$GITHUB_OUTPUT"
        shell: bash

  deploy_each_app: # Job 2: Deploys each app found in the previous job
    needs: find_apps
    runs-on: ubuntu-latest
    if: ${{ needs.find_apps.outputs.app_dirs_json != '[]' }}
    strategy:
      fail-fast: false # Allow other apps to deploy even if one fails
      matrix:
        app_dir: ${{ fromJson(needs.find_apps.outputs.app_dirs_json) }}

    env:
      HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
      HEROKU_EMAIL: ${{ secrets.HEROKU_EMAIL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Heroku CLI
        run: |
          curl https://cli-assets.heroku.com/install.sh | sh

      - name: Install jq (for package.json parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Read App Config and Prepare Deploy Variables
        id: prepare_vars
        run: |
          set -e
          APP_DIR="${{ matrix.app_dir }}"
          echo "Current APP_DIR: $APP_DIR" # Debugging line
          APP_FOLDER_NAME=$(basename "$APP_DIR")
          PACKAGE_JSON_APP_NAME=$(jq -r '.name' "$APP_DIR/package.json" || echo "")
          HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "")

          # Consistency Check: Folder Name vs. package.json 'name'
          if [ "$APP_FOLDER_NAME" != "$PACKAGE_JSON_APP_NAME" ]; then
            echo "::error::Inconsistency detected for app '${APP_FOLDER_NAME}' (path: '${APP_DIR}'):"
            echo "::error::Folder name ('${APP_FOLDER_NAME}') does NOT match 'name' in package.json ('${PACKAGE_JSON_APP_NAME}')."
            echo "::error::Please **rename either the folder or the 'name' in package.json to match**, then commit and re-run."
            exit 1 # Fail this specific matrix job
          fi

          # Heroku App Name Check
          if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
            echo "::error::'herokuAppName' field not found or is empty in '$APP_DIR/package.json'."
            echo "::error::Please add '\"herokuAppName\": \"YOUR_HEROKU_APP_NAME\"' to this package.json file."
            exit 1 # Fail this specific matrix job
          fi
          
          echo "Installing dependencies for ${APP_FOLDER_NAME} (path: '${APP_DIR}')..."
          npm install --prefix "$APP_DIR" || {
              echo "::error::npm install failed for app in '${APP_DIR}'. Deployment failed for this app."
              exit 1 # Fail this specific matrix job
          }

          # Output variables that the subsequent 'uses' step can consume
          echo "heroku_app_name=$HEROKU_APP_TARGET_NAME" >> "$GITHUB_OUTPUT"
          echo "app_folder_name=$APP_FOLDER_NAME" >> "$GITHUB_OUTPUT"

        shell: bash

      - name: Deploy to Heroku - Actual Action
        id: deploy_action
        uses: akhileshns/heroku-deploy@v3.13.15
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          heroku_app_name: ${{ steps.prepare_vars.outputs.heroku_app_name }}
          appdir: ${{ matrix.app_dir }}

  generate_app_list_file: # Job 3: Generates apps.md file using Python
    needs: [find_apps, deploy_each_app] # This job needs both previous jobs
    runs-on: ubuntu-latest
    if: |
      always() && # Always run so we can report status regardless of previous job's individual matrix failures
      needs.find_apps.outputs.app_dirs_json != '[]' # Only run if apps were found to deploy

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }} # Checkout the branch we're working on

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x' # Use a recent Python version

      - name: Generate apps.md Content with Python
        id: generate_content_py
        run: |
          python -c '
import json
import os
import sys

# Get app directories JSON from the previous job's output
app_dirs_json = os.environ.get("APP_DIRS_JSON_FROM_FIND_APPS") # Received via env var
if not app_dirs_json:
    print("::error::APP_DIRS_JSON_FROM_FIND_APPS environment variable is missing.", file=sys.stderr)
    sys.exit(1)

try:
    app_dirs = json.loads(app_dirs_json)
except json.JSONDecodeError:
    print(f"::error::Failed to parse JSON: {app_dirs_json}", file=sys.stderr)
    sys.exit(1)

apps_md_content = "# ðŸš€ Deployed Applications\\n\\n"
apps_md_content += "This file lists the applications deployed from this repository to Heroku.\\n\\n"
apps_md_content += "## App List\\n\\n"
apps_updated_flag = False

# Read package.json for each app to get herokuAppName
# This requires re-reading the files from the checked out repository.
for app_dir in app_dirs:
    app_folder_name = os.path.basename(app_dir)
    package_json_path = os.path.join(app_dir, "package.json")
    
    if not os.path.exists(package_json_path):
        print(f"::warning::package.json not found for {app_folder_name} at {app_dir}. Skipping.", file=sys.stderr)
        continue

    try:
        with open(package_json_path, "r") as f:
            package_json_data = json.load(f)
        
        heroku_app_target_name = package_json_data.get("herokuAppName")
        
        if not heroku_app_target_name:
            print(f"::warning::Skipping apps.md entry for \'{app_folder_name}\' as \'herokuAppName\' is missing or empty in its package.json.", file=sys.stderr)
            continue
        
        app_url = f"https://{heroku_app_target_name}.herokuapp.com/"
        apps_md_content += f"* **{app_folder_name}:** [{app_url}]({app_url})\\n"
        apps_updated_flag = True

    except Exception as e:
        print(f"::error::Error processing {package_json_path}: {e}", file=sys.stderr)
        continue

# Output the generated content and a flag indicating if there\'s anything to write
# Encode newlines for GITHUB_OUTPUT as it expects a single-line string
# (GitHub Actions automatically decodes %0A back to newline for subsequent steps)
escaped_content = apps_md_content.replace("\\n", "%0A").replace("\\r", "%0D").replace("%", "%25")
print(f"apps_md_section_content={escaped_content}")
print(f"apps_md_updated_flag={str(apps_updated_flag).lower()}")
# Write directly to $GITHUB_OUTPUT file
print(f"apps_md_section_content={escaped_content}", file=open(os.environ["GITHUB_OUTPUT"], "a"))
print(f"apps_md_updated_flag={str(apps_updated_flag).lower()}", file=open(os.environ["GITHUB_OUTPUT"], "a"))
          '
        env:
          # Pass the JSON list of app directories as an environment variable to the Python script
          APP_DIRS_JSON_FROM_FIND_APPS: ${{ needs.find_apps.outputs.app_dirs_json }}
        shell: bash # Use bash to run the python command

      - name: Write apps.md File
        if: ${{ steps.generate_content_py.outputs.apps_md_updated_flag == 'true' }}
        run: |
          # Decode the content (Python script should have already escaped it)
          APPS_MD_SECTION_CONTENT="${{ steps.generate_content_py.outputs.apps_md_section_content }}"

          echo "$APPS_MD_SECTION_CONTENT" > apps.md # Write directly to apps.md
        shell: bash

      - name: Commit and Push apps.md
        if: ${{ steps.generate_content_py.outputs.apps_md_updated_flag == 'true' }}
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Docs: Update deployed app links in apps.md"
          branch: main
          token: ${{ secrets.GITHUB_TOKEN }}
