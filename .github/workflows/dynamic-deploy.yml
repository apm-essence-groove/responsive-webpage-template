name: Dynamic Multi-App Heroku Deploy

on:
  push:
    branches:
      - main # Or 'master'
    paths:
      - 'homepage-app/**'
      - 'to_do_list/**'
      - '.github/workflows/dynamic-deploy.yml'

jobs:
  find_apps: # Job 1: Finds all deployable app directories
    runs-on: ubuntu-latest
    outputs:
      app_dirs_json: ${{ steps.scan.outputs.app_dirs_json }}
    env:
      APP_BASE_DIRS: "homepage-app to_do_list" # Your top-level folders for apps

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq (for package.json parsing and JSON output)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Scan for Apps
        id: scan
        run: |
          set -e

          ALL_APP_DIRS_ARRAY=()
          echo "Scanning for apps in: $APP_BASE_DIRS"
          for BASE_DIR in $APP_BASE_DIRS; do
            FOUND_DIRS=$(find "$BASE_DIR" -type f -name "package.json" -exec dirname {} \;)
            for DIR in $FOUND_DIRS; do
              ALL_APP_DIRS_ARRAY+=("$DIR")
            done
          done

          UNIQUE_APP_DIRS_NEWLINES=$(printf "%s\n" "${ALL_APP_DIRS_ARRAY[@]}" | sort -u)

          if [ -z "$UNIQUE_APP_DIRS_NEWLINES" ]; then
            echo "No applications found with package.json in '$APP_BASE_DIRS'. Exiting."
            printf "app_dirs_json=[]\n" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found applications in directories (for debugging):"
          echo "$UNIQUE_APP_DIRS_NEWLINES"

          APP_DIRS_JSON=$(echo "$UNIQUE_APP_DIRS_NEWLINES" | jq -R . | jq -s -c .)
          echo "Generated JSON (single line): $APP_DIRS_JSON"

          printf "app_dirs_json=%s\n" "$APP_DIRS_JSON" >> "$GITHUB_OUTPUT"
        shell: bash

  deploy_each_app: # Job 2: Deploys each app found in the previous job
    needs: find_apps
    runs-on: ubuntu-latest
    if: ${{ needs.find_apps.outputs.app_dirs_json != '[]' }}
    strategy:
      fail-fast: false # Allow other apps to deploy even if one fails
      matrix:
        app_dir: ${{ fromJson(needs.find_apps.outputs.app_dirs_json) }}

    env:
      HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
      HEROKU_EMAIL: ${{ secrets.HEROKU_EMAIL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Heroku CLI
        run: |
          curl https://cli-assets.heroku.com/install.sh | sh

      - name: Install jq (for package.json parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Read App Config and Prepare Deploy Variables
        id: prepare_vars # ID this step
        run: |
          set -e
          APP_DIR="${{ matrix.app_dir }}"
          APP_FOLDER_NAME=$(basename "$APP_DIR")
          PACKAGE_JSON_APP_NAME=$(jq -r '.name' "$APP_DIR/package.json" || echo "")
          HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "")

          # Consistency Check
          if [ "$APP_FOLDER_NAME" != "$PACKAGE_JSON_APP_NAME" ]; then
            echo "::error::Inconsistency: Folder name ('${APP_FOLDER_NAME}') != package.json name ('${PACKAGE_JSON_APP_NAME}')."
            exit 1
          fi
          if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
            echo "::error::'herokuAppName' missing or empty in '$APP_DIR/package.json'."
            exit 1
          fi

          echo "Installing dependencies for ${APP_FOLDER_NAME} (path: '${APP_DIR}')..."
          npm install --prefix "$APP_DIR" || {
              echo "::error::npm install failed for app in '${APP_DIR}'."
              exit 1
          }

          # Output variables that the subsequent 'uses' step can consume
          echo "heroku_app_name=$HEROKU_APP_TARGET_NAME" >> "$GITHUB_OUTPUT"
          echo "app_folder_name=$APP_FOLDER_NAME" >> "$GITHUB_OUTPUT" # Output folder name for README

        shell: bash

      - name: Deploy to Heroku - Actual Action
        id: deploy_action # ID the deploy step to check its status
        uses: akhileshns/heroku-deploy@v3.13.15
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          heroku_app_name: ${{ steps.prepare_vars.outputs.heroku_app_name }}
          appdir: ${{ matrix.app_dir }}

      - name: Store Deployed App URL (if successful)
        if: success() # Only run this if the 'Deploy to Heroku' step was successful
        id: store_url
        run: |
          APP_FOLDER_NAME="${{ steps.prepare_vars.outputs.app_folder_name }}"
          HEROKU_APP_NAME="${{ steps.prepare_vars.outputs.heroku_app_name }}"
          APP_URL="https://${HEROKU_APP_NAME}.herokuapp.com/"
          
          # Store the URL in a way that the final update step can access it.
          # We'll use a temporary file, but its content will be read in a *later* job.
          # For a matrix, this means each matrix instance writes to its own temp file.
          
          # This requires outputting a specific structure to a file.
          # A better way is to use a dedicated step to aggregate all URLs
          # after the matrix job completes.

          # We need to output the app name and URL so the next job can gather them.
          echo "deployed_app_name=$APP_FOLDER_NAME" >> "$GITHUB_OUTPUT"
          echo "deployed_app_url=$APP_URL" >> "$GITHUB_OUTPUT"

  update_readme: # Job 3: Updates README.md after all deployments
    needs: deploy_each_app # This job depends on the successful completion of the deploy_each_app job
    runs-on: ubuntu-latest
    # This 'if' condition ensures this job runs only if 'deploy_each_app' ran and completed successfully,
    # and if any apps were actually deployed (i.e., the app_dirs_json was not empty).
    if: |
      always() && # Run always, then check individual job statuses
      needs.deploy_each_app.result == 'success' && # Ensure the deployment job was successful
      needs.find_apps.outputs.app_dirs_json != '[]' # Ensure there were apps to deploy

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Extract Deployed App Info
        id: extract_info
        run: |
          set -e
          echo "Extracting information from completed deploy_each_app jobs..."
          
          # Retrieve the job outputs for each matrix iteration
          # This is complex as there isn't a direct way to get *all* matrix outputs.
          # We need to parse the raw GitHub context.

          # --- Simpler approach: Use a specific GitHub Action to gather outputs ---
          # Or, if this were less dynamic, each 'deploy_each_app' step could have
          # written to a uniquely named file and this job would glob them.
          # However, that's not ideal for robustness.

          # A common pattern for this is to pass the entire list of app_dirs_json
          # again to this job, then loop through it and reconstruct URLs.

          # Re-fetch the app directories from find_apps job output
          APP_DIRS_JSON="${{ needs.find_apps.outputs.app_dirs_json }}"
          APP_DIRS=$(echo "$APP_DIRS_JSON" | jq -r '.[]') # Convert JSON array back to newline-separated strings

          README_CONTENT="## ðŸš€ Live Demos\n\n"
          README_UPDATED_FLAG=false

          for APP_DIR in $APP_DIRS; do
            APP_FOLDER_NAME=$(basename "$APP_DIR")
            HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "") # Need to re-read from repo
            
            if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
                echo "::warning::Skipping README update for '${APP_FOLDER_NAME}' as 'herokuAppName' is missing."
                continue
            fi
            
            APP_URL="https://${HEROKU_APP_TARGET_NAME}.herokuapp.com/"
            README_CONTENT+="* **${APP_FOLDER_NAME}:** [${APP_URL}](${APP_URL})\n"
            README_UPDATED_FLAG=true
          done

          # Output the generated content and a flag indicating if there's anything to write
          echo "readme_section_content=$(echo -e "$README_CONTENT" | sed 's/%/%25/g;s/\n/%0A/g;s/\r/%0D/g')" >> "$GITHUB_OUTPUT"
          echo "readme_updated_flag=$README_UPDATED_FLAG" >> "$GITHUB_OUTPUT"
        shell: bash

      update_readme: # Job 3: Updates README.md after all deployments
    needs: deploy_each_app # This job depends on the successful completion of the deploy_each_app job
    runs-on: ubuntu-latest
    # FIX: Removed comments from the 'if:' condition
    if: |
      always() &&
      needs.deploy_each_app.result == 'success' &&
      needs.find_apps.outputs.app_dirs_json != '[]'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Extract Deployed App Info
        id: extract_info
        run: |
          set -e
          echo "Extracting information from completed deploy_each_app jobs..."
          
          APP_DIRS_JSON="${{ needs.find_apps.outputs.app_dirs_json }}"
          APP_DIRS=$(echo "$APP_DIRS_JSON" | jq -r '.[]')

          README_CONTENT="## ðŸš€ Live Demos\n\n"
          README_UPDATED_FLAG=false

          for APP_DIR in $APP_DIRS; do
            APP_FOLDER_NAME=$(basename "$APP_DIR")
            
            # Re-read package.json to get herokuAppName as it's not passed directly from matrix
            HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "") 
            
            if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
                echo "::warning::Skipping README update for '${APP_FOLDER_NAME}' as 'herokuAppName' is missing in its package.json."
                continue
            fi
            
            APP_URL="https://${HEROKU_APP_TARGET_NAME}.herokuapp.com/"
            README_CONTENT+="* **${APP_FOLDER_NAME}:** [${APP_URL}](${APP_URL})\n"
            README_UPDATED_FLAG=true
          done

          # Output the generated content and a flag indicating if there's anything to write
          # The sed command here is for encoding, necessary for multi-line output
          echo "readme_section_content=$(echo -e "$README_CONTENT" | sed 's/%/%25/g;s/\n/%0A/g;s/\r/%0D/g')" >> "$GITHUB_OUTPUT"
          echo "readme_updated_flag=$README_UPDATED_FLAG" >> "$GITHUB_OUTPUT"
        shell: bash

      update_readme: # Job 3: Updates README.md after all deployments
    needs: deploy_each_app # This job depends on the successful completion of the deploy_each_app job
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.deploy_each_app.result == 'success' &&
      needs.find_apps.outputs.app_dirs_json != '[]'

    steps: # <--- This 'steps' should be indented by 2 spaces from 'update_readme'
      - name: Checkout code # <--- This '- name' should be indented by 4 spaces
        uses: actions/checkout@v4 # <--- This 'uses' should be indented by 6 spaces

      - name: Install jq # <--- This '- name' should be indented by 4 spaces
        run: sudo apt-get update && sudo apt-get install -y jq # <--- This 'run' should be indented by 6 spaces

      - name: Extract Deployed App Info # <--- This '- name' should be indented by 4 spaces
        id: extract_info # <--- This 'id' should be indented by 6 spaces
        run: | # <--- This 'run' should be indented by 6 spaces
          set -e
          echo "Extracting information from completed deploy_each_app jobs..."
          
          # Re-fetch the app directories from find_apps job output
          APP_DIRS_JSON="${{ needs.find_apps.outputs.app_dirs_json }}"
          APP_DIRS=$(echo "$APP_DIRS_JSON" | jq -r '.[]') # Convert JSON array back to newline-separated strings

          README_CONTENT="## ðŸš€ Live Demos\n\n"
          README_UPDATED_FLAG=false

          for APP_DIR in $APP_DIRS; do
            APP_FOLDER_NAME=$(basename "$APP_DIR")
            
            # Re-read package.json to get herokuAppName as it's not passed directly from matrix
            HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "") 
            
            if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
                echo "::warning::Skipping README update for '${APP_FOLDER_NAME}' as 'herokuAppName' is missing in its package.json."
                continue
            fi
            
            APP_URL="https://${HEROKU_APP_TARGET_NAME}.herokuapp.com/"
            README_CONTENT+="* **${APP_FOLDER_NAME}:** [${APP_URL}](${APP_URL})\n"
            README_UPDATED_FLAG=true
          done

          # Output the generated content and a flag indicating if there's anything to write
          echo "readme_section_content=$(echo -e "$README_CONTENT" | sed 's/%/%25/g;s/\n/%0A/g;s/\r/%0D/g')" >> "$GITHUB_OUTPUT"
          echo "readme_updated_flag=$README_UPDATED_FLAG" >> "$GITHUB_OUTPUT"
        shell: bash

      update_readme: # Job 3: Updates README.md after all deployments
    needs: deploy_each_app # This job depends on the successful completion of the deploy_each_app job
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.deploy_each_app.result == 'success' &&
      needs.find_apps.outputs.app_dirs_json != '[]'

    steps: # <--- This line must be exactly 2 spaces indented from 'update_readme:'
      - name: Checkout code # <--- This line must be exactly 4 spaces indented from 'update_readme:'
        uses: actions/checkout@v4 # <--- This line must be exactly 6 spaces indented from 'update_readme:'

      - name: Install jq # <--- This line must be exactly 4 spaces indented
        run: sudo apt-get update && sudo apt-get install -y jq # <--- This line must be exactly 6 spaces indented

      - name: Extract Deployed App Info # <--- This line must be exactly 4 spaces indented
        id: extract_info # <--- This line must be exactly 6 spaces indented
        run: | # <--- This line must be exactly 6 spaces indented. The content below it will be 8 spaces.
          set -e
          echo "Extracting information from completed deploy_each_app jobs..."
          
          # Re-fetch the app directories from find_apps job output
          APP_DIRS_JSON="${{ needs.find_apps.outputs.app_dirs_json }}"
          APP_DIRS=$(echo "$APP_DIRS_JSON" | jq -r '.[]') # Convert JSON array back to newline-separated strings

          README_CONTENT="## ðŸš€ Live Demos\n\n"
          README_UPDATED_FLAG=false

          for APP_DIR in $APP_DIRS; do
            APP_FOLDER_NAME=$(basename "$APP_DIR")
            
            # Re-read package.json to get herokuAppName as it's not passed directly from matrix
            HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "") 
            
            if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
                echo "::warning::Skipping README update for '${APP_FOLDER_NAME}' as 'herokuAppName' is missing in its package.json."
                continue
            fi
            
            APP_URL="https://${HEROKU_APP_TARGET_NAME}.herokuapp.com/"
            README_CONTENT+="* **${APP_FOLDER_NAME}:** [${APP_URL}](${APP_URL})\n"
            README_UPDATED_FLAG=true
          done

          # Output the generated content and a flag indicating if there's anything to write
          echo "readme_section_content=$(echo -e "$README_CONTENT" | sed 's/%/%25/g;s/\n/%0A/g;s/\r/%0D/g')" >> "$GITHUB_OUTPUT"
          echo "readme_updated_flag=$README_UPDATED_FLAG" >> "$GITHUB_OUTPUT"
        shell: bash # <--- This line must be exactly 8 spaces indented

      update_readme: # Job 3: Updates README.md after all deployments
    needs: deploy_each_app # This job depends on the successful completion of the deploy_each_app job
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.deploy_each_app.result == 'success' &&
      needs.find_apps.outputs.app_dirs_json != '[]'

    steps: # <--- This 'steps' should be indented by 2 spaces from 'update_readme:'
      - name: Checkout code # <--- This '- name' should be indented by 4 spaces
        uses: actions/checkout@v4 # <--- This 'uses' should be indented by 6 spaces

      - name: Install jq # <--- This '- name' should be indented by 4 spaces
        run: sudo apt-get update && sudo apt-get install -y jq # <--- This 'run' should be indented by 6 spaces

      - name: Extract Deployed App Info # <--- This '- name' should be indented by 4 spaces
        id: extract_info # <--- This 'id' should be indented by 6 spaces
        run: | # <--- This 'run' should be indented by 6 spaces. The content below it will be 8 spaces.
          set -e
          echo "Extracting information from completed deploy_each_app jobs..."
          
          # Re-fetch the app directories from find_apps job output
          APP_DIRS_JSON="${{ needs.find_apps.outputs.app_dirs_json }}"
          APP_DIRS=$(echo "$APP_DIRS_JSON" | jq -r '.[]') # Convert JSON array back to newline-separated strings

          README_CONTENT="## ðŸš€ Live Demos\n\n"
          README_UPDATED_FLAG=false

          for APP_DIR in $APP_DIRS; do
            APP_FOLDER_NAME=$(basename "$APP_DIR")
            
            # Re-read package.json to get herokuAppName as it's not passed directly from matrix
            HEROKU_APP_TARGET_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "") 
            
            if [ -z "$HEROKU_APP_TARGET_NAME" ] || [ "$HEROKU_APP_TARGET_NAME" == "null" ]; then
                echo "::warning::Skipping README update for '${APP_FOLDER_NAME}' as 'herokuAppName' is missing in its package.json."
                continue
            fi
            
            APP_URL="https://${HEROKU_APP_TARGET_NAME}.herokuapp.com/"
            README_CONTENT+="* **${APP_FOLDER_NAME}:** [${APP_URL}](${APP_URL})\n"
            README_UPDATED_FLAG=true
          done

          # Output the generated content and a flag indicating if there's anything to write
          echo "readme_section_content=$(echo -e "$README_CONTENT" | sed 's/%/%25/g;s/\n/%0A/g;s/\r/%0D/g')" >> "$GITHUB_OUTPUT"
          echo "readme_updated_flag=$README_UPDATED_FLAG" >> "$GITHUB_OUTPUT"
        shell: bash # <--- This line must be exactly 8 spaces indented

      - name: Update README.md # <--- This line must be exactly 4 spaces indented
        if: ${{ steps.extract_info.outputs.readme_updated_flag == 'true' }} # <--- This line must be exactly 6 spaces indented
        run: | # <--- This line must be exactly 6 spaces indented. The content below it will be 8 spaces.
          # Decode the content
          README_SECTION_CONTENT=$(echo "${{ steps.extract_info.outputs.readme_section_content }}" | sed 's/%0A/\n/g;s/%0D/\r/g;s/%25/%/g')

          # Define start and end markers in your README.md
          # Make sure these exact markers exist in your README.md file
          START_MARKER=""
          END_MARKER=""

          # Use awk for a more robust way to replace content between markers
          awk -v start="$START_MARKER" -v end="$END_MARKER" -v content="$README_SECTION_CONTENT" '
              $0 ~ start { print; print content; in_block=1; next }
              $0 ~ end { print; in_block=0; next }
              !in_block { print }
          ' README.md > README.md.tmp && mv README.md.tmp README.md
        shell: bash # <--- This line must be exactly 8 spaces indented

      - name: Commit and Push README.md # <--- This line must be exactly 4 spaces indented
        if: ${{ steps.extract_info.outputs.readme_updated_flag == 'true' }} # <--- This line must be exactly 6 spaces indented
        uses: stefanzweifel/git-auto-commit-action@v5 # <--- This line must be exactly 6 spaces indented
        with: # <--- This line must be exactly 8 spaces indented
          commit_message: "Docs: Update deployed app links in README.md" # <--- This line must be exactly 10 spaces indented
          branch: main # <--- This line must be exactly 10 spaces indented
